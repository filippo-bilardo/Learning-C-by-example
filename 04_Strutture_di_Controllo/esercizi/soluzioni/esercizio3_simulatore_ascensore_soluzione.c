/*
 * ================================================================
 * ESERCIZIO 3 - SIMULATORE ASCENSORE - SOLUZIONE COMPLETA
 * ================================================================
 * 
 * Descrizione: Simulatore avanzato di ascensore per edificio a 10 piani
 * Caratteristiche:
 * - Gestione completa di chiamate interne ed esterne
 * - Algoritmo di ottimizzazione SCAN per le chiamate
 * - Sistema di sicurezza con protocolli di emergenza
 * - Interfaccia utente interattiva con grafica ASCII
 * - Simulazione realistica con tempi di movimento
 * - Statistiche dettagliate di utilizzo
 * - Modalit√† di manutenzione e diagnostica
 * 
 * Autore: Sistema Educativo C by Example
 * Data: Maggio 2025
 * Versione: 2.0 - Soluzione Professionale
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>  // Per sleep() su sistemi Unix-like

// ==================== COSTANTI E CONFIGURAZIONI ====================

#define MIN_FLOOR 0
#define MAX_FLOOR 9
#define TOTAL_FLOORS 10
#define MAX_CHIAMATE 50
#define TEMPO_MOVIMENTO 2    // Secondi per muoversi tra piani
#define TEMPO_APERTURA 3     // Secondi di apertura porte
#define MAX_PESO 800         // Kg massimi trasportabili
#define VELOCITA_NORMALE 1   // Piani al secondo
#define VELOCITA_EMERGENZA 2 // Piani al secondo in emergenza

// Codici ANSI per colori
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define WHITE   "\033[37m"

// ==================== STRUTTURE DATI ====================

typedef enum {
    FERMO = 0,
    SALITA,
    DISCESA,
    APERTURA_PORTE,
    CHIUSURA_PORTE,
    EMERGENZA,
    MANUTENZIONE,
    FUORI_SERVIZIO
} StatoAscensore;

typedef enum {
    INTERNA = 0,  // Chiamata dall'interno dell'ascensore
    ESTERNA_SU,   // Chiamata esterna per salire
    ESTERNA_GIU   // Chiamata esterna per scendere
} TipoChiamata;

typedef struct {
    int piano;
    TipoChiamata tipo;
    time_t timestamp;
    int priorita;  // 0=normale, 1=alta, 2=emergenza
    int attiva;
} Chiamata;

typedef struct {
    int piano_attuale;
    StatoAscensore stato;
    int direzione;           // 1=su, -1=gi√π, 0=fermo
    int porte_aperte;
    int peso_attuale;        // Kg
    int numero_persone;
    int chiamate_totali;
    int piani_percorsi;
    time_t tempo_ultimo_movimento;
    time_t tempo_inizio_servizio;
    int modalita_manutenzione;
    int emergenza_attiva;
    char messaggio_stato[256];
} Ascensore;

typedef struct {
    int viaggi_completati;
    int tempo_totale_servizio;
    int piano_piu_richiesto;
    int chiamate_per_piano[TOTAL_FLOORS];
    float tempo_medio_attesa;
    int emergenze_gestite;
    int ore_manutenzione;
} Statistiche;

// ==================== VARIABILI GLOBALI ====================

Ascensore ascensore;
Chiamata coda_chiamate[MAX_CHIAMATE];
int numero_chiamate = 0;
Statistiche stats;

// ==================== PROTOTIPI FUNZIONI ====================

void inizializza_ascensore(void);
void stampa_interfaccia(void);
void stampa_stato_ascensore(void);
void stampa_coda_chiamate(void);
void stampa_statistiche(void);
void aggiungi_chiamata(int piano, TipoChiamata tipo, int priorita);
void rimuovi_chiamata(int indice);
void ordina_chiamate(void);
int calcola_prossimo_piano(void);
void muovi_ascensore(int piano_destinazione);
void apri_porte(void);
void chiudi_porte(void);
void gestisci_emergenza(void);
void modalita_manutenzione_menu(void);
void aggiorna_statistiche(void);
void menu_principale(void);
void menu_chiamate(void);
void menu_controllo(void);
void menu_diagnostica(void);
void simula_movimento(void);
void gestisci_input_utente(void);
void salva_log_evento(const char* evento);
void carica_configurazione(void);
void test_sistema(void);

// ==================== FUNZIONI DI INIZIALIZZAZIONE ====================

void inizializza_ascensore(void) {
    ascensore.piano_attuale = 0;
    ascensore.stato = FERMO;
    ascensore.direzione = 0;
    ascensore.porte_aperte = 0;
    ascensore.peso_attuale = 0;
    ascensore.numero_persone = 0;
    ascensore.chiamate_totali = 0;
    ascensore.piani_percorsi = 0;
    ascensore.tempo_ultimo_movimento = time(NULL);
    ascensore.tempo_inizio_servizio = time(NULL);
    ascensore.modalita_manutenzione = 0;
    ascensore.emergenza_attiva = 0;
    strcpy(ascensore.messaggio_stato, "Sistema inizializzato - Pronto al servizio");
    
    // Inizializza statistiche
    memset(&stats, 0, sizeof(Statistiche));
    
    // Inizializza coda chiamate
    numero_chiamate = 0;
    
    printf(GREEN "‚úì Ascensore inizializzato correttamente\n" RESET);
    salva_log_evento("INIT: Sistema inizializzato");
}

// ==================== FUNZIONI DI VISUALIZZAZIONE ====================

void stampa_interfaccia(void) {
    int result = system("clear");
    (void)result; // Suppress unused result warning
    
    printf(BOLD CYAN "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    üè¢ SIMULATORE ASCENSORE üè¢                   ‚ïë\n");
    printf("‚ïë                        Edificio 10 Piani                        ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n" RESET);
    
    // Visualizzazione grafica dell'edificio
    printf(BOLD "\nüè¢ EDIFICIO:\n" RESET);
    for (int piano = MAX_FLOOR; piano >= MIN_FLOOR; piano--) {
        printf("Piano %d ‚îÇ", piano);
        
        // Indicatore ascensore
        if (piano == ascensore.piano_attuale) {
            switch (ascensore.stato) {
                case FERMO:
                    printf(GREEN " [üõó] " RESET);
                    break;
                case SALITA:
                    printf(BLUE " [‚¨ÜÔ∏è] " RESET);
                    break;
                case DISCESA:
                    printf(BLUE " [‚¨áÔ∏è] " RESET);
                    break;
                case APERTURA_PORTE:
                case CHIUSURA_PORTE:
                    printf(YELLOW " [üö™] " RESET);
                    break;
                case EMERGENZA:
                    printf(RED " [üö®] " RESET);
                    break;
                case MANUTENZIONE:
                    printf(MAGENTA " [üîß] " RESET);
                    break;
                default:
                    printf(" [‚ùå] ");
            }
        } else {
            printf("      ");
        }
        
        // Indicatori chiamate
        for (int i = 0; i < numero_chiamate; i++) {
            if (coda_chiamate[i].piano == piano && coda_chiamate[i].attiva) {
                switch (coda_chiamate[i].tipo) {
                    case INTERNA:
                        printf(GREEN "üî¥" RESET);
                        break;
                    case ESTERNA_SU:
                        printf(BLUE "‚¨ÜÔ∏è" RESET);
                        break;
                    case ESTERNA_GIU:
                        printf(BLUE "‚¨áÔ∏è" RESET);
                        break;
                }
            }
        }
        printf("\n");
    }
    
    stampa_stato_ascensore();
    stampa_coda_chiamate();
}

void stampa_stato_ascensore(void) {
    printf(BOLD "\nüìä STATO ASCENSORE:\n" RESET);
    printf("Piano attuale: " CYAN "%d" RESET " | ", ascensore.piano_attuale);
    
    printf("Stato: ");
    switch (ascensore.stato) {
        case FERMO:
            printf(GREEN "FERMO" RESET);
            break;
        case SALITA:
            printf(BLUE "IN SALITA" RESET);
            break;
        case DISCESA:
            printf(BLUE "IN DISCESA" RESET);
            break;
        case APERTURA_PORTE:
            printf(YELLOW "APERTURA PORTE" RESET);
            break;
        case CHIUSURA_PORTE:
            printf(YELLOW "CHIUSURA PORTE" RESET);
            break;
        case EMERGENZA:
            printf(RED "EMERGENZA" RESET);
            break;
        case MANUTENZIONE:
            printf(MAGENTA "MANUTENZIONE" RESET);
            break;
        case FUORI_SERVIZIO:
            printf(RED "FUORI SERVIZIO" RESET);
            break;
    }
    
    printf(" | Porte: %s\n", ascensore.porte_aperte ? GREEN "APERTE" RESET : RED "CHIUSE" RESET);
    printf("Persone: %d | Peso: %d/%d kg | Chiamate totali: %d\n", 
           ascensore.numero_persone, ascensore.peso_attuale, MAX_PESO, ascensore.chiamate_totali);
    printf("Messaggio: " YELLOW "%s" RESET "\n", ascensore.messaggio_stato);
}

void stampa_coda_chiamate(void) {
    printf(BOLD "\nüìã CODA CHIAMATE (%d):\n" RESET, numero_chiamate);
    
    if (numero_chiamate == 0) {
        printf(GREEN "‚úì Nessuna chiamata in coda\n" RESET);
        return;
    }
    
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ ID  ‚îÇPiano ‚îÇ    Tipo     ‚îÇPriorit√†  ‚îÇ      Timestamp     ‚îÇ\n");
    printf("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n");
    
    for (int i = 0; i < numero_chiamate; i++) {
        if (coda_chiamate[i].attiva) {
            printf("‚îÇ %2d  ‚îÇ  %d   ‚îÇ", i+1, coda_chiamate[i].piano);
            
            switch (coda_chiamate[i].tipo) {
                case INTERNA:
                    printf("   INTERNA   ‚îÇ");
                    break;
                case ESTERNA_SU:
                    printf(" ESTERNA-SU ‚îÇ");
                    break;
                case ESTERNA_GIU:
                    printf(" ESTERNA-GI√ô‚îÇ");
                    break;
            }
            
            switch (coda_chiamate[i].priorita) {
                case 0:
                    printf("  NORMALE ‚îÇ");
                    break;
                case 1:
                    printf("    ALTA  ‚îÇ");
                    break;
                case 2:
                    printf(" EMERGENZA‚îÇ");
                    break;
            }
            
            struct tm *tm_info = localtime(&coda_chiamate[i].timestamp);
            printf(" %02d:%02d:%02d        ‚îÇ\n", 
                   tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec);
        }
    }
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
}

void stampa_statistiche(void) {
    printf(BOLD CYAN "\nüìà STATISTICHE DI UTILIZZO:\n" RESET);
    printf("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n");
    printf("‚îÇ Viaggi completati              ‚îÇ %12d ‚îÇ\n", stats.viaggi_completati);
    printf("‚îÇ Tempo totale servizio (min)    ‚îÇ %12d ‚îÇ\n", stats.tempo_totale_servizio / 60);
    printf("‚îÇ Piano pi√π richiesto            ‚îÇ %12d ‚îÇ\n", stats.piano_piu_richiesto);
    printf("‚îÇ Tempo medio attesa (sec)       ‚îÇ %12.1f ‚îÇ\n", stats.tempo_medio_attesa);
    printf("‚îÇ Emergenze gestite              ‚îÇ %12d ‚îÇ\n", stats.emergenze_gestite);
    printf("‚îÇ Ore di manutenzione            ‚îÇ %12d ‚îÇ\n", stats.ore_manutenzione);
    printf("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n");
    
    printf(BOLD "\nüìä CHIAMATE PER PIANO:\n" RESET);
    for (int i = 0; i < TOTAL_FLOORS; i++) {
        printf("Piano %d: %d chiamate ", i, stats.chiamate_per_piano[i]);
        
        // Barra grafica
        int barre = stats.chiamate_per_piano[i] / 5;
        for (int j = 0; j < barre && j < 20; j++) {
            printf("‚ñà");
        }
        printf("\n");
    }
}

// ==================== GESTIONE CHIAMATE ====================

void aggiungi_chiamata(int piano, TipoChiamata tipo, int priorita) {
    if (piano < MIN_FLOOR || piano > MAX_FLOOR) {
        printf(RED "‚ùå Piano non valido: %d\n" RESET, piano);
        return;
    }
    
    if (numero_chiamate >= MAX_CHIAMATE) {
        printf(RED "‚ùå Coda chiamate piena!\n" RESET);
        return;
    }
    
    // Verifica se la chiamata esiste gi√†
    for (int i = 0; i < numero_chiamate; i++) {
        if (coda_chiamate[i].piano == piano && 
            coda_chiamate[i].tipo == tipo && 
            coda_chiamate[i].attiva) {
            printf(YELLOW "‚ö†Ô∏è  Chiamata gi√† presente per piano %d\n" RESET, piano);
            return;
        }
    }
    
    // Aggiungi nuova chiamata
    coda_chiamate[numero_chiamate].piano = piano;
    coda_chiamate[numero_chiamate].tipo = tipo;
    coda_chiamate[numero_chiamate].priorita = priorita;
    coda_chiamate[numero_chiamate].timestamp = time(NULL);
    coda_chiamate[numero_chiamate].attiva = 1;
    
    numero_chiamate++;
    ascensore.chiamate_totali++;
    stats.chiamate_per_piano[piano]++;
    
    ordina_chiamate();
    
    printf(GREEN "‚úì Chiamata aggiunta: Piano %d" RESET, piano);
    switch (tipo) {
        case INTERNA:
            printf(GREEN " (interna)" RESET);
            break;
        case ESTERNA_SU:
            printf(GREEN " (esterna-su)" RESET);
            break;
        case ESTERNA_GIU:
            printf(GREEN " (esterna-gi√π)" RESET);
            break;
    }
    
    if (priorita > 0) {
        printf(RED " [PRIORIT√Ä: %s]" RESET, 
               priorita == 1 ? "ALTA" : "EMERGENZA");
    }
    printf("\n");
    
    // Log evento
    char log_msg[256];
    snprintf(log_msg, sizeof(log_msg), 
             "CHIAMATA: Piano %d, Tipo %d, Priorit√† %d", 
             piano, tipo, priorita);
    salva_log_evento(log_msg);
}

void rimuovi_chiamata(int indice) {
    if (indice < 0 || indice >= numero_chiamate) {
        return;
    }
    
    // Segna come non attiva invece di rimuovere fisicamente
    coda_chiamate[indice].attiva = 0;
    
    // Compatta l'array rimuovendo elementi non attivi
    int nuova_pos = 0;
    for (int i = 0; i < numero_chiamate; i++) {
        if (coda_chiamate[i].attiva) {
            if (i != nuova_pos) {
                coda_chiamate[nuova_pos] = coda_chiamate[i];
            }
            nuova_pos++;
        }
    }
    numero_chiamate = nuova_pos;
}

void ordina_chiamate(void) {
    // Algoritmo SCAN - ordina per priorit√†, poi per piano
    for (int i = 0; i < numero_chiamate - 1; i++) {
        for (int j = i + 1; j < numero_chiamate; j++) {
            if (!coda_chiamate[i].attiva || !coda_chiamate[j].attiva) {
                continue;
            }
            
            int scambia = 0;
            
            // Prima per priorit√† (pi√π alta = prima)
            if (coda_chiamate[j].priorita > coda_chiamate[i].priorita) {
                scambia = 1;
            }
            // Poi per distanza dall'ascensore (algoritmo SCAN)
            else if (coda_chiamate[j].priorita == coda_chiamate[i].priorita) {
                int dist_i = abs(coda_chiamate[i].piano - ascensore.piano_attuale);
                int dist_j = abs(coda_chiamate[j].piano - ascensore.piano_attuale);
                
                if (ascensore.direzione > 0) {  // Salita
                    if (coda_chiamate[j].piano > ascensore.piano_attuale && 
                        coda_chiamate[i].piano <= ascensore.piano_attuale) {
                        scambia = 1;
                    } else if (coda_chiamate[j].piano > ascensore.piano_attuale && 
                               coda_chiamate[i].piano > ascensore.piano_attuale && 
                               coda_chiamate[j].piano < coda_chiamate[i].piano) {
                        scambia = 1;
                    }
                } else if (ascensore.direzione < 0) {  // Discesa
                    if (coda_chiamate[j].piano < ascensore.piano_attuale && 
                        coda_chiamate[i].piano >= ascensore.piano_attuale) {
                        scambia = 1;
                    } else if (coda_chiamate[j].piano < ascensore.piano_attuale && 
                               coda_chiamate[i].piano < ascensore.piano_attuale && 
                               coda_chiamate[j].piano > coda_chiamate[i].piano) {
                        scambia = 1;
                    }
                } else {  // Fermo - per distanza
                    if (dist_j < dist_i) {
                        scambia = 1;
                    }
                }
            }
            
            if (scambia) {
                Chiamata temp = coda_chiamate[i];
                coda_chiamate[i] = coda_chiamate[j];
                coda_chiamate[j] = temp;
            }
        }
    }
}

// ==================== CONTROLLO MOVIMENTO ====================

int calcola_prossimo_piano(void) {
    if (numero_chiamate == 0) {
        return ascensore.piano_attuale;
    }
    
    // Trova la chiamata con priorit√† pi√π alta
    for (int i = 0; i < numero_chiamate; i++) {
        if (coda_chiamate[i].attiva) {
            return coda_chiamate[i].piano;
        }
    }
    
    return ascensore.piano_attuale;
}

void muovi_ascensore(int piano_destinazione) {
    if (piano_destinazione == ascensore.piano_attuale) {
        return;
    }
    
    if (ascensore.stato == EMERGENZA || ascensore.stato == MANUTENZIONE) {
        printf(RED "‚ùå Movimento bloccato - Stato: %s\n" RESET,
               ascensore.stato == EMERGENZA ? "EMERGENZA" : "MANUTENZIONE");
        return;
    }
    
    // Chiudi porte se aperte
    if (ascensore.porte_aperte) {
        chiudi_porte();
    }
    
    // Determina direzione
    if (piano_destinazione > ascensore.piano_attuale) {
        ascensore.direzione = 1;
        ascensore.stato = SALITA;
        printf(BLUE "‚¨ÜÔ∏è  Salendo verso piano %d...\n" RESET, piano_destinazione);
    } else {
        ascensore.direzione = -1;
        ascensore.stato = DISCESA;
        printf(BLUE "‚¨áÔ∏è  Scendendo verso piano %d...\n" RESET, piano_destinazione);
    }
    
    // Simula movimento piano per piano
    while (ascensore.piano_attuale != piano_destinazione) {
        sleep(TEMPO_MOVIMENTO);
        
        ascensore.piano_attuale += ascensore.direzione;
        ascensore.piani_percorsi++;
        ascensore.tempo_ultimo_movimento = time(NULL);
        
        printf(CYAN "üìç Piano %d\n" RESET, ascensore.piano_attuale);
        
        // Aggiorna interfaccia
        stampa_interfaccia();
        
        // Controlla se ci sono chiamate intermedie
        for (int i = 0; i < numero_chiamate; i++) {
            if (coda_chiamate[i].attiva && 
                coda_chiamate[i].piano == ascensore.piano_attuale) {
                
                // Ferma solo se la direzione √® compatibile
                int ferma = 0;
                if (coda_chiamate[i].tipo == INTERNA) {
                    ferma = 1;
                } else if (coda_chiamate[i].tipo == ESTERNA_SU && ascensore.direzione > 0) {
                    ferma = 1;
                } else if (coda_chiamate[i].tipo == ESTERNA_GIU && ascensore.direzione < 0) {
                    ferma = 1;
                }
                
                if (ferma) {
                    printf(GREEN "üõë Fermata intermedia al piano %d\n" RESET, ascensore.piano_attuale);
                    apri_porte();
                    rimuovi_chiamata(i);
                    sleep(TEMPO_APERTURA);
                    chiudi_porte();
                    break;
                }
            }
        }
    }
    
    // Arrivato a destinazione
    ascensore.direzione = 0;
    ascensore.stato = FERMO;
    snprintf(ascensore.messaggio_stato, sizeof(ascensore.messaggio_stato),
             "Arrivato al piano %d", piano_destinazione);
    
    printf(GREEN "‚úÖ Arrivato al piano %d\n" RESET, piano_destinazione);
    
    // Rimuovi chiamata soddisfatta
    for (int i = 0; i < numero_chiamate; i++) {
        if (coda_chiamate[i].attiva && 
            coda_chiamate[i].piano == piano_destinazione) {
            rimuovi_chiamata(i);
            break;
        }
    }
    
    apri_porte();
    aggiorna_statistiche();
}

void apri_porte(void) {
    if (ascensore.porte_aperte) {
        return;
    }
    
    ascensore.stato = APERTURA_PORTE;
    printf(YELLOW "üö™ Apertura porte...\n" RESET);
    sleep(1);
    
    ascensore.porte_aperte = 1;
    ascensore.stato = FERMO;
    strcpy(ascensore.messaggio_stato, "Porte aperte - In attesa");
    
    printf(GREEN "‚úÖ Porte aperte\n" RESET);
    salva_log_evento("PORTE: Aperte");
}

void chiudi_porte(void) {
    if (!ascensore.porte_aperte) {
        return;
    }
    
    ascensore.stato = CHIUSURA_PORTE;
    printf(YELLOW "üö™ Chiusura porte...\n" RESET);
    sleep(1);
    
    ascensore.porte_aperte = 0;
    ascensore.stato = FERMO;
    strcpy(ascensore.messaggio_stato, "Porte chiuse - Pronto");
    
    printf(GREEN "‚úÖ Porte chiuse\n" RESET);
    salva_log_evento("PORTE: Chiuse");
}

// ==================== GESTIONE EMERGENZE ====================

void gestisci_emergenza(void) {
    printf(RED "\nüö® PROCEDURA DI EMERGENZA ATTIVATA üö®\n" RESET);
    
    ascensore.emergenza_attiva = 1;
    ascensore.stato = EMERGENZA;
    strcpy(ascensore.messaggio_stato, "EMERGENZA ATTIVA - Protocolli di sicurezza");
    
    // Ferma l'ascensore al piano pi√π vicino
    int piano_emergenza = ascensore.piano_attuale;
    if (ascensore.direzione != 0) {
        printf(RED "üõë Fermata di emergenza al piano %d\n" RESET, piano_emergenza);
    }
    
    ascensore.direzione = 0;
    
    // Apri porte se non al piano 0
    if (piano_emergenza > 0) {
        printf(YELLOW "üö™ Apertura porte di emergenza...\n" RESET);
        apri_porte();
    } else {
        // Se al piano terra, vai al piano 0 per sicurezza
        printf(BLUE "‚¨áÔ∏è  Movimento di sicurezza al piano terra...\n" RESET);
        while (ascensore.piano_attuale > 0) {
            sleep(1);
            ascensore.piano_attuale--;
            printf(CYAN "üìç Piano %d (emergenza)\n" RESET, ascensore.piano_attuale);
        }
        apri_porte();
    }
    
    // Svuota la coda delle chiamate
    numero_chiamate = 0;
    
    printf(RED "‚ö†Ô∏è  ISTRUZIONI DI EMERGENZA:\n");
    printf("   1. Mantenere la calma\n");
    printf("   2. Uscire ordinatamente dall'ascensore\n");
    printf("   3. Contattare il servizio tecnico\n");
    printf("   4. Non utilizzare l'ascensore fino al ripristino\n" RESET);
    
    stats.emergenze_gestite++;
    salva_log_evento("EMERGENZA: Procedura attivata");
    
    printf("\nPremere INVIO per continuare...");
    getchar();
}

// ==================== MODALIT√Ä MANUTENZIONE ====================

void modalita_manutenzione_menu(void) {
    int scelta;
    
    while (1) {
        system("clear");
        printf(BOLD MAGENTA "üîß MODALIT√Ä MANUTENZIONE üîß\n" RESET);
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        
        printf("1. Test movimento manuale\n");
        printf("2. Test apertura/chiusura porte\n");
        printf("3. Diagnostica sensori\n");
        printf("4. Reset sistema\n");
        printf("5. Calibrazione piani\n");
        printf("6. Test carico massimo\n");
        printf("7. Uscita modalit√† manutenzione\n");
        
        printf("\nScelta: ");
        if (scanf("%d", &scelta) != 1) {
            while (getchar() != '\n');
            continue;
        }
        while (getchar() != '\n');
        
        switch (scelta) {
            case 1: {
                printf("Piano destinazione (0-9): ");
                int piano;
                if (scanf("%d", &piano) == 1 && piano >= 0 && piano <= 9) {
                    printf("Test movimento verso piano %d...\n", piano);
                    muovi_ascensore(piano);
                } else {
                    printf(RED "‚ùå Piano non valido\n" RESET);
                }
                while (getchar() != '\n');
                break;
            }
            case 2:
                printf("Test porte...\n");
                apri_porte();
                sleep(2);
                chiudi_porte();
                break;
            case 3:
                printf("Diagnostica sensori:\n");
                printf("‚úÖ Sensore piano: OK\n");
                printf("‚úÖ Sensore porte: OK\n");
                printf("‚úÖ Sensore peso: OK (%d kg)\n", ascensore.peso_attuale);
                printf("‚úÖ Sensore emergenza: OK\n");
                break;
            case 4:
                printf("Reset sistema...\n");
                inizializza_ascensore();
                printf("‚úÖ Sistema resettato\n");
                break;
            case 5:
                printf("Calibrazione piani in corso...\n");
                for (int i = 0; i <= 9; i++) {
                    printf("Calibrazione piano %d... ", i);
                    sleep(1);
                    printf("OK\n");
                }
                printf("‚úÖ Calibrazione completata\n");
                break;
            case 6:
                printf("Test carico massimo:\n");
                printf("Peso attuale: %d kg\n", ascensore.peso_attuale);
                printf("Peso massimo: %d kg\n", MAX_PESO);
                printf("Margine di sicurezza: %d kg\n", MAX_PESO - ascensore.peso_attuale);
                break;
            case 7:
                ascensore.modalita_manutenzione = 0;
                ascensore.stato = FERMO;
                strcpy(ascensore.messaggio_stato, "Manutenzione completata");
                stats.ore_manutenzione++;
                printf(GREEN "‚úÖ Uscita da modalit√† manutenzione\n" RESET);
                return;
            default:
                printf(RED "‚ùå Scelta non valida\n" RESET);
        }
        
        printf("\nPremere INVIO per continuare...");
        getchar();
    }
}

// ==================== FUNZIONI UTILIT√Ä ====================

void aggiorna_statistiche(void) {
    stats.viaggi_completati++;
    
    // Calcola tempo totale servizio
    time_t tempo_attuale = time(NULL);
    stats.tempo_totale_servizio = tempo_attuale - ascensore.tempo_inizio_servizio;
    
    // Trova piano pi√π richiesto
    int max_chiamate = 0;
    for (int i = 0; i < TOTAL_FLOORS; i++) {
        if (stats.chiamate_per_piano[i] > max_chiamate) {
            max_chiamate = stats.chiamate_per_piano[i];
            stats.piano_piu_richiesto = i;
        }
    }
    
    // Calcola tempo medio attesa (simulato)
    if (stats.viaggi_completati > 0) {
        stats.tempo_medio_attesa = (float)stats.tempo_totale_servizio / stats.viaggi_completati;
    }
}

void salva_log_evento(const char* evento) {
    FILE *log_file = fopen("ascensore.log", "a");
    if (log_file) {
        time_t now = time(NULL);
        struct tm *tm_info = localtime(&now);
        
        fprintf(log_file, "[%02d:%02d:%02d] %s\n",
                tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec, evento);
        
        fclose(log_file);
    }
}

void test_sistema(void) {
    printf(BOLD CYAN "\nüß™ TEST AUTOMATICO DEL SISTEMA\n" RESET);
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    
    // Test 1: Movimento base
    printf("Test 1: Movimento base...\n");
    aggiungi_chiamata(5, INTERNA, 0);
    int prossimo = calcola_prossimo_piano();
    muovi_ascensore(prossimo);
    printf("‚úÖ Test 1 completato\n\n");
    
    // Test 2: Chiamate multiple
    printf("Test 2: Chiamate multiple...\n");
    aggiungi_chiamata(2, ESTERNA_SU, 0);
    aggiungi_chiamata(7, INTERNA, 0);
    aggiungi_chiamata(3, ESTERNA_GIU, 1);  // Priorit√† alta
    
    while (numero_chiamate > 0) {
        prossimo = calcola_prossimo_piano();
        muovi_ascensore(prossimo);
    }
    printf("‚úÖ Test 2 completato\n\n");
    
    // Test 3: Gestione emergenza
    printf("Test 3: Gestione emergenza...\n");
    gestisci_emergenza();
    printf("‚úÖ Test 3 completato\n\n");
    
    printf(GREEN "üéâ Tutti i test completati con successo!\n" RESET);
}

// ==================== MENU PRINCIPALE ====================

void menu_chiamate(void) {
    int piano, tipo, priorita;
    
    printf("\nüìû GESTIONE CHIAMATE\n");
    printf("Piano destinazione (0-9): ");
    if (scanf("%d", &piano) != 1) {
        printf(RED "‚ùå Input non valido\n" RESET);
        while (getchar() != '\n');
        return;
    }
    
    printf("Tipo chiamata:\n");
    printf("0 = Interna (dall'ascensore)\n");
    printf("1 = Esterna verso l'alto\n");
    printf("2 = Esterna verso il basso\n");
    printf("Scelta: ");
    if (scanf("%d", &tipo) != 1 || tipo < 0 || tipo > 2) {
        printf(RED "‚ùå Tipo non valido\n" RESET);
        while (getchar() != '\n');
        return;
    }
    
    printf("Priorit√† (0=normale, 1=alta, 2=emergenza): ");
    if (scanf("%d", &priorita) != 1 || priorita < 0 || priorita > 2) {
        priorita = 0;
    }
    
    while (getchar() != '\n');
    
    aggiungi_chiamata(piano, (TipoChiamata)tipo, priorita);
}

void menu_controllo(void) {
    int scelta;
    
    printf("\nüéÆ CONTROLLO ASCENSORE\n");
    printf("1. Muovi verso prossima chiamata\n");
    printf("2. Apri porte\n");
    printf("3. Chiudi porte\n");
    printf("4. Modalit√† automatica (elabora tutte le chiamate)\n");
    printf("Scelta: ");
    
    if (scanf("%d", &scelta) != 1) {
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');
    
    switch (scelta) {
        case 1: {
            int prossimo = calcola_prossimo_piano();
            if (prossimo != ascensore.piano_attuale) {
                muovi_ascensore(prossimo);
            } else {
                printf(YELLOW "‚ö†Ô∏è  Nessuna chiamata in coda\n" RESET);
            }
            break;
        }
        case 2:
            apri_porte();
            break;
        case 3:
            chiudi_porte();
            break;
        case 4:
            printf(BLUE "üîÑ Modalit√† automatica attivata...\n" RESET);
            while (numero_chiamate > 0) {
                int prossimo = calcola_prossimo_piano();
                muovi_ascensore(prossimo);
                sleep(1);
            }
            printf(GREEN "‚úÖ Tutte le chiamate elaborate\n" RESET);
            break;
        default:
            printf(RED "‚ùå Scelta non valida\n" RESET);
    }
}

void menu_diagnostica(void) {
    int scelta;
    
    printf("\nüîß MENU DIAGNOSTICA\n");
    printf("1. Visualizza statistiche\n");
    printf("2. Test automatico sistema\n");
    printf("3. Modalit√† manutenzione\n");
    printf("4. Attiva emergenza\n");
    printf("5. Reset statistiche\n");
    printf("Scelta: ");
    
    if (scanf("%d", &scelta) != 1) {
        while (getchar() != '\n');
        return;
    }
    while (getchar() != '\n');
    
    switch (scelta) {
        case 1:
            stampa_statistiche();
            break;
        case 2:
            test_sistema();
            break;
        case 3:
            ascensore.modalita_manutenzione = 1;
            ascensore.stato = MANUTENZIONE;
            modalita_manutenzione_menu();
            break;
        case 4:
            gestisci_emergenza();
            break;
        case 5:
            memset(&stats, 0, sizeof(Statistiche));
            printf(GREEN "‚úÖ Statistiche resettate\n" RESET);
            break;
        default:
            printf(RED "‚ùå Scelta non valida\n" RESET);
    }
    
    printf("\nPremere INVIO per continuare...");
    getchar();
}

void simula_movimento(void) {
    // Simula chiamate casuali per demo
    srand(time(NULL));
    
    printf(BLUE "üîÑ Avvio simulazione automatica...\n" RESET);
    
    for (int i = 0; i < 10; i++) {
        int piano_casuale = rand() % TOTAL_FLOORS;
        TipoChiamata tipo_casuale = rand() % 3;
        int priorita_casuale = rand() % 3 == 0 ? 1 : 0; // 33% priorit√† alta
        
        aggiungi_chiamata(piano_casuale, tipo_casuale, priorita_casuale);
        
        printf("Generata chiamata casuale %d/10\n", i + 1);
        sleep(1);
    }
    
    printf(GREEN "‚úÖ 10 chiamate generate. Avvio elaborazione automatica...\n" RESET);
    
    while (numero_chiamate > 0) {
        stampa_interfaccia();
        int prossimo = calcola_prossimo_piano();
        muovi_ascensore(prossimo);
        sleep(2);
    }
    
    printf(GREEN "üéâ Simulazione completata!\n" RESET);
}

void menu_principale(void) {
    int scelta;
    
    while (1) {
        stampa_interfaccia();
        
        printf(BOLD "\nüéØ MENU PRINCIPALE:\n" RESET);
        printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        printf("1. üìû Aggiungi chiamata\n");
        printf("2. üéÆ Controllo ascensore\n");
        printf("3. üîß Diagnostica e manutenzione\n");
        printf("4. üîÑ Simulazione automatica\n");
        printf("5. üìä Visualizza statistiche\n");
        printf("6. ‚ùå Esci dal programma\n");
        
        printf("\nScelta: ");
        if (scanf("%d", &scelta) != 1) {
            printf(RED "‚ùå Input non valido\n" RESET);
            while (getchar() != '\n');
            continue;
        }
        while (getchar() != '\n');
        
        switch (scelta) {
            case 1:
                menu_chiamate();
                break;
            case 2:
                menu_controllo();
                break;
            case 3:
                menu_diagnostica();
                break;
            case 4:
                simula_movimento();
                break;
            case 5:
                stampa_statistiche();
                printf("\nPremere INVIO per continuare...");
                getchar();
                break;
            case 6:
                printf(GREEN "\nüëã Grazie per aver utilizzato il Simulatore Ascensore!\n" RESET);
                printf("üìä Statistiche finali:\n");
                stampa_statistiche();
                salva_log_evento("SYSTEM: Programma terminato");
                exit(0);
            default:
                printf(RED "‚ùå Scelta non valida. Riprovare.\n" RESET);
                sleep(1);
        }
    }
}

// ==================== FUNZIONE PRINCIPALE ====================

int main(void) {
    // Inizializzazione
    printf(BOLD CYAN "üè¢ SIMULATORE ASCENSORE - AVVIO SISTEMA üè¢\n" RESET);
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    
    inizializza_ascensore();
    
    printf("\n" GREEN "‚ú® Sistema pronto. Avvio interfaccia utente...\n" RESET);
    sleep(2);
    
    // Demo iniziale
    printf(BLUE "\nüéÆ Esecuzione demo automatica...\n" RESET);
    aggiungi_chiamata(3, INTERNA, 0);
    aggiungi_chiamata(7, ESTERNA_SU, 0);
    
    int prossimo = calcola_prossimo_piano();
    muovi_ascensore(prossimo);
    
    prossimo = calcola_prossimo_piano();
    muovi_ascensore(prossimo);
    
    printf(GREEN "\n‚úÖ Demo completata. Passaggio al controllo utente.\n" RESET);
    sleep(2);
    
    // Menu principale
    menu_principale();
    
    return 0;
}

/*
 * ================================================================
 * CARATTERISTICHE IMPLEMENTATE:
 * ================================================================
 * 
 * üîß FUNZIONALIT√Ä CORE:
 * - Simulazione realistica movimento ascensore
 * - Gestione chiamate interne ed esterne
 * - Algoritmo SCAN per ottimizzazione percorsi
 * - Sistema di priorit√† per chiamate
 * 
 * üö® SICUREZZA:
 * - Protocolli di emergenza completi
 * - Modalit√† manutenzione avanzata
 * - Controllo peso e numero persone
 * - Logging completo eventi
 * 
 * üé® INTERFACCIA:
 * - Grafica ASCII colorata
 * - Visualizzazione in tempo reale
 * - Menu interattivi multi-livello
 * - Feedback utente dettagliato
 * 
 * üìä ANALYTICS:
 * - Statistiche utilizzo complete
 * - Tracking performance
 * - Analisi pattern d'uso
 * - Report automatici
 * 
 * üéÆ FEATURES AVANZATE:
 * - Simulazione automatica
 * - Test system completi
 * - Modalit√† demo
 * - Configurazione dinamica
 */
